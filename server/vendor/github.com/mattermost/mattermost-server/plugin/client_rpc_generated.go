// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make pluginapi"
// DO NOT EDIT

package plugin

import (
	"fmt"

	"github.com/mattermost/mattermost-server/mlog"
	"github.com/mattermost/mattermost-server/model"
)

func init() {
	HookNameToId["OnDeactivate"] = OnDeactivateId
}

type OnDeactivateArgs struct {
}

type OnDeactivateReturns struct {
	A error
}

func (g *HooksRPCClient) OnDeactivate() error {
	_args := &OnDeactivateArgs{}
	_returns := &OnDeactivateReturns{}
	if g.implemented[OnDeactivateId] {
		if err := g.client.Call("Plugin.OnDeactivate", _args, _returns); err != nil {
			g.log.Error("RPC call OnDeactivate to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *HooksRPCServer) OnDeactivate(args *OnDeactivateArgs, returns *OnDeactivateReturns) error {
	if hook, ok := s.impl.(interface {
		OnDeactivate() error
	}); ok {
		returns.A = hook.OnDeactivate()
	} else {
		return fmt.Errorf("Hook OnDeactivate called but not implemented.")
	}
	return nil
}

func init() {
	HookNameToId["OnConfigurationChange"] = OnConfigurationChangeId
}

type OnConfigurationChangeArgs struct {
}

type OnConfigurationChangeReturns struct {
	A error
}

func (g *HooksRPCClient) OnConfigurationChange() error {
	_args := &OnConfigurationChangeArgs{}
	_returns := &OnConfigurationChangeReturns{}
	if g.implemented[OnConfigurationChangeId] {
		if err := g.client.Call("Plugin.OnConfigurationChange", _args, _returns); err != nil {
			g.log.Error("RPC call OnConfigurationChange to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *HooksRPCServer) OnConfigurationChange(args *OnConfigurationChangeArgs, returns *OnConfigurationChangeReturns) error {
	if hook, ok := s.impl.(interface {
		OnConfigurationChange() error
	}); ok {
		returns.A = hook.OnConfigurationChange()
	} else {
		return fmt.Errorf("Hook OnConfigurationChange called but not implemented.")
	}
	return nil
}

func init() {
	HookNameToId["ExecuteCommand"] = ExecuteCommandId
}

type ExecuteCommandArgs struct {
	A *Context
	B *model.CommandArgs
}

type ExecuteCommandReturns struct {
	A *model.CommandResponse
	B *model.AppError
}

func (g *HooksRPCClient) ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	_args := &ExecuteCommandArgs{c, args}
	_returns := &ExecuteCommandReturns{}
	if g.implemented[ExecuteCommandId] {
		if err := g.client.Call("Plugin.ExecuteCommand", _args, _returns); err != nil {
			g.log.Error("RPC call ExecuteCommand to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *HooksRPCServer) ExecuteCommand(args *ExecuteCommandArgs, returns *ExecuteCommandReturns) error {
	if hook, ok := s.impl.(interface {
		ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.ExecuteCommand(args.A, args.B)
	} else {
		return fmt.Errorf("Hook ExecuteCommand called but not implemented.")
	}
	return nil
}

func init() {
	HookNameToId["MessageWillBePosted"] = MessageWillBePostedId
}

type MessageWillBePostedArgs struct {
	A *Context
	B *model.Post
}

type MessageWillBePostedReturns struct {
	A *model.Post
	B string
}

func (g *HooksRPCClient) MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string) {
	_args := &MessageWillBePostedArgs{c, post}
	_returns := &MessageWillBePostedReturns{}
	if g.implemented[MessageWillBePostedId] {
		if err := g.client.Call("Plugin.MessageWillBePosted", _args, _returns); err != nil {
			g.log.Error("RPC call MessageWillBePosted to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *HooksRPCServer) MessageWillBePosted(args *MessageWillBePostedArgs, returns *MessageWillBePostedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string)
	}); ok {
		returns.A, returns.B = hook.MessageWillBePosted(args.A, args.B)
	} else {
		return fmt.Errorf("Hook MessageWillBePosted called but not implemented.")
	}
	return nil
}

func init() {
	HookNameToId["MessageWillBeUpdated"] = MessageWillBeUpdatedId
}

type MessageWillBeUpdatedArgs struct {
	A *Context
	B *model.Post
	C *model.Post
}

type MessageWillBeUpdatedReturns struct {
	A *model.Post
	B string
}

func (g *HooksRPCClient) MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string) {
	_args := &MessageWillBeUpdatedArgs{c, newPost, oldPost}
	_returns := &MessageWillBeUpdatedReturns{}
	if g.implemented[MessageWillBeUpdatedId] {
		if err := g.client.Call("Plugin.MessageWillBeUpdated", _args, _returns); err != nil {
			g.log.Error("RPC call MessageWillBeUpdated to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *HooksRPCServer) MessageWillBeUpdated(args *MessageWillBeUpdatedArgs, returns *MessageWillBeUpdatedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string)
	}); ok {
		returns.A, returns.B = hook.MessageWillBeUpdated(args.A, args.B, args.C)
	} else {
		return fmt.Errorf("Hook MessageWillBeUpdated called but not implemented.")
	}
	return nil
}

func init() {
	HookNameToId["MessageHasBeenPosted"] = MessageHasBeenPostedId
}

type MessageHasBeenPostedArgs struct {
	A *Context
	B *model.Post
}

type MessageHasBeenPostedReturns struct {
}

func (g *HooksRPCClient) MessageHasBeenPosted(c *Context, post *model.Post) {
	_args := &MessageHasBeenPostedArgs{c, post}
	_returns := &MessageHasBeenPostedReturns{}
	if g.implemented[MessageHasBeenPostedId] {
		if err := g.client.Call("Plugin.MessageHasBeenPosted", _args, _returns); err != nil {
			g.log.Error("RPC call MessageHasBeenPosted to plugin failed.", mlog.Err(err))
		}
	}
	return
}

func (s *HooksRPCServer) MessageHasBeenPosted(args *MessageHasBeenPostedArgs, returns *MessageHasBeenPostedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageHasBeenPosted(c *Context, post *model.Post)
	}); ok {
		hook.MessageHasBeenPosted(args.A, args.B)
	} else {
		return fmt.Errorf("Hook MessageHasBeenPosted called but not implemented.")
	}
	return nil
}

func init() {
	HookNameToId["MessageHasBeenUpdated"] = MessageHasBeenUpdatedId
}

type MessageHasBeenUpdatedArgs struct {
	A *Context
	B *model.Post
	C *model.Post
}

type MessageHasBeenUpdatedReturns struct {
}

func (g *HooksRPCClient) MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post) {
	_args := &MessageHasBeenUpdatedArgs{c, newPost, oldPost}
	_returns := &MessageHasBeenUpdatedReturns{}
	if g.implemented[MessageHasBeenUpdatedId] {
		if err := g.client.Call("Plugin.MessageHasBeenUpdated", _args, _returns); err != nil {
			g.log.Error("RPC call MessageHasBeenUpdated to plugin failed.", mlog.Err(err))
		}
	}
	return
}

func (s *HooksRPCServer) MessageHasBeenUpdated(args *MessageHasBeenUpdatedArgs, returns *MessageHasBeenUpdatedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post)
	}); ok {
		hook.MessageHasBeenUpdated(args.A, args.B, args.C)
	} else {
		return fmt.Errorf("Hook MessageHasBeenUpdated called but not implemented.")
	}
	return nil
}

type RegisterCommandArgs struct {
	A *model.Command
}

type RegisterCommandReturns struct {
	A error
}

func (g *APIRPCClient) RegisterCommand(command *model.Command) error {
	_args := &RegisterCommandArgs{command}
	_returns := &RegisterCommandReturns{}
	if err := g.client.Call("Plugin.RegisterCommand", _args, _returns); err != nil {
		g.log.Error("RPC call to RegisterCommand API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) RegisterCommand(args *RegisterCommandArgs, returns *RegisterCommandReturns) error {
	if hook, ok := s.impl.(interface {
		RegisterCommand(command *model.Command) error
	}); ok {
		returns.A = hook.RegisterCommand(args.A)
	} else {
		return fmt.Errorf("API RegisterCommand called but not implemented.")
	}
	return nil
}

type UnregisterCommandArgs struct {
	A string
	B string
}

type UnregisterCommandReturns struct {
	A error
}

func (g *APIRPCClient) UnregisterCommand(teamId, trigger string) error {
	_args := &UnregisterCommandArgs{teamId, trigger}
	_returns := &UnregisterCommandReturns{}
	if err := g.client.Call("Plugin.UnregisterCommand", _args, _returns); err != nil {
		g.log.Error("RPC call to UnregisterCommand API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) UnregisterCommand(args *UnregisterCommandArgs, returns *UnregisterCommandReturns) error {
	if hook, ok := s.impl.(interface {
		UnregisterCommand(teamId, trigger string) error
	}); ok {
		returns.A = hook.UnregisterCommand(args.A, args.B)
	} else {
		return fmt.Errorf("API UnregisterCommand called but not implemented.")
	}
	return nil
}

type CreateUserArgs struct {
	A *model.User
}

type CreateUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *APIRPCClient) CreateUser(user *model.User) (*model.User, *model.AppError) {
	_args := &CreateUserArgs{user}
	_returns := &CreateUserReturns{}
	if err := g.client.Call("Plugin.CreateUser", _args, _returns); err != nil {
		g.log.Error("RPC call to CreateUser API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) CreateUser(args *CreateUserArgs, returns *CreateUserReturns) error {
	if hook, ok := s.impl.(interface {
		CreateUser(user *model.User) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateUser(args.A)
	} else {
		return fmt.Errorf("API CreateUser called but not implemented.")
	}
	return nil
}

type DeleteUserArgs struct {
	A string
}

type DeleteUserReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) DeleteUser(userId string) *model.AppError {
	_args := &DeleteUserArgs{userId}
	_returns := &DeleteUserReturns{}
	if err := g.client.Call("Plugin.DeleteUser", _args, _returns); err != nil {
		g.log.Error("RPC call to DeleteUser API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) DeleteUser(args *DeleteUserArgs, returns *DeleteUserReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteUser(userId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteUser(args.A)
	} else {
		return fmt.Errorf("API DeleteUser called but not implemented.")
	}
	return nil
}

type GetUserArgs struct {
	A string
}

type GetUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *APIRPCClient) GetUser(userId string) (*model.User, *model.AppError) {
	_args := &GetUserArgs{userId}
	_returns := &GetUserReturns{}
	if err := g.client.Call("Plugin.GetUser", _args, _returns); err != nil {
		g.log.Error("RPC call to GetUser API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetUser(args *GetUserArgs, returns *GetUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetUser(userId string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUser(args.A)
	} else {
		return fmt.Errorf("API GetUser called but not implemented.")
	}
	return nil
}

type GetUserByEmailArgs struct {
	A string
}

type GetUserByEmailReturns struct {
	A *model.User
	B *model.AppError
}

func (g *APIRPCClient) GetUserByEmail(email string) (*model.User, *model.AppError) {
	_args := &GetUserByEmailArgs{email}
	_returns := &GetUserByEmailReturns{}
	if err := g.client.Call("Plugin.GetUserByEmail", _args, _returns); err != nil {
		g.log.Error("RPC call to GetUserByEmail API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetUserByEmail(args *GetUserByEmailArgs, returns *GetUserByEmailReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByEmail(email string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByEmail(args.A)
	} else {
		return fmt.Errorf("API GetUserByEmail called but not implemented.")
	}
	return nil
}

type GetUserByUsernameArgs struct {
	A string
}

type GetUserByUsernameReturns struct {
	A *model.User
	B *model.AppError
}

func (g *APIRPCClient) GetUserByUsername(name string) (*model.User, *model.AppError) {
	_args := &GetUserByUsernameArgs{name}
	_returns := &GetUserByUsernameReturns{}
	if err := g.client.Call("Plugin.GetUserByUsername", _args, _returns); err != nil {
		g.log.Error("RPC call to GetUserByUsername API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetUserByUsername(args *GetUserByUsernameArgs, returns *GetUserByUsernameReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByUsername(name string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByUsername(args.A)
	} else {
		return fmt.Errorf("API GetUserByUsername called but not implemented.")
	}
	return nil
}

type UpdateUserArgs struct {
	A *model.User
}

type UpdateUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *APIRPCClient) UpdateUser(user *model.User) (*model.User, *model.AppError) {
	_args := &UpdateUserArgs{user}
	_returns := &UpdateUserReturns{}
	if err := g.client.Call("Plugin.UpdateUser", _args, _returns); err != nil {
		g.log.Error("RPC call to UpdateUser API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) UpdateUser(args *UpdateUserArgs, returns *UpdateUserReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUser(user *model.User) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUser(args.A)
	} else {
		return fmt.Errorf("API UpdateUser called but not implemented.")
	}
	return nil
}

type CreateTeamArgs struct {
	A *model.Team
}

type CreateTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *APIRPCClient) CreateTeam(team *model.Team) (*model.Team, *model.AppError) {
	_args := &CreateTeamArgs{team}
	_returns := &CreateTeamReturns{}
	if err := g.client.Call("Plugin.CreateTeam", _args, _returns); err != nil {
		g.log.Error("RPC call to CreateTeam API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) CreateTeam(args *CreateTeamArgs, returns *CreateTeamReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeam(team *model.Team) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeam(args.A)
	} else {
		return fmt.Errorf("API CreateTeam called but not implemented.")
	}
	return nil
}

type DeleteTeamArgs struct {
	A string
}

type DeleteTeamReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) DeleteTeam(teamId string) *model.AppError {
	_args := &DeleteTeamArgs{teamId}
	_returns := &DeleteTeamReturns{}
	if err := g.client.Call("Plugin.DeleteTeam", _args, _returns); err != nil {
		g.log.Error("RPC call to DeleteTeam API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) DeleteTeam(args *DeleteTeamArgs, returns *DeleteTeamReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteTeam(teamId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteTeam(args.A)
	} else {
		return fmt.Errorf("API DeleteTeam called but not implemented.")
	}
	return nil
}

type GetTeamArgs struct {
	A string
}

type GetTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *APIRPCClient) GetTeam(teamId string) (*model.Team, *model.AppError) {
	_args := &GetTeamArgs{teamId}
	_returns := &GetTeamReturns{}
	if err := g.client.Call("Plugin.GetTeam", _args, _returns); err != nil {
		g.log.Error("RPC call to GetTeam API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetTeam(args *GetTeamArgs, returns *GetTeamReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeam(teamId string) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeam(args.A)
	} else {
		return fmt.Errorf("API GetTeam called but not implemented.")
	}
	return nil
}

type GetTeamByNameArgs struct {
	A string
}

type GetTeamByNameReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *APIRPCClient) GetTeamByName(name string) (*model.Team, *model.AppError) {
	_args := &GetTeamByNameArgs{name}
	_returns := &GetTeamByNameReturns{}
	if err := g.client.Call("Plugin.GetTeamByName", _args, _returns); err != nil {
		g.log.Error("RPC call to GetTeamByName API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetTeamByName(args *GetTeamByNameArgs, returns *GetTeamByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamByName(name string) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamByName(args.A)
	} else {
		return fmt.Errorf("API GetTeamByName called but not implemented.")
	}
	return nil
}

type UpdateTeamArgs struct {
	A *model.Team
}

type UpdateTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *APIRPCClient) UpdateTeam(team *model.Team) (*model.Team, *model.AppError) {
	_args := &UpdateTeamArgs{team}
	_returns := &UpdateTeamReturns{}
	if err := g.client.Call("Plugin.UpdateTeam", _args, _returns); err != nil {
		g.log.Error("RPC call to UpdateTeam API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) UpdateTeam(args *UpdateTeamArgs, returns *UpdateTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateTeam(team *model.Team) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateTeam(args.A)
	} else {
		return fmt.Errorf("API UpdateTeam called but not implemented.")
	}
	return nil
}

type CreateChannelArgs struct {
	A *model.Channel
}

type CreateChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *APIRPCClient) CreateChannel(channel *model.Channel) (*model.Channel, *model.AppError) {
	_args := &CreateChannelArgs{channel}
	_returns := &CreateChannelReturns{}
	if err := g.client.Call("Plugin.CreateChannel", _args, _returns); err != nil {
		g.log.Error("RPC call to CreateChannel API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) CreateChannel(args *CreateChannelArgs, returns *CreateChannelReturns) error {
	if hook, ok := s.impl.(interface {
		CreateChannel(channel *model.Channel) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateChannel(args.A)
	} else {
		return fmt.Errorf("API CreateChannel called but not implemented.")
	}
	return nil
}

type DeleteChannelArgs struct {
	A string
}

type DeleteChannelReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) DeleteChannel(channelId string) *model.AppError {
	_args := &DeleteChannelArgs{channelId}
	_returns := &DeleteChannelReturns{}
	if err := g.client.Call("Plugin.DeleteChannel", _args, _returns); err != nil {
		g.log.Error("RPC call to DeleteChannel API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) DeleteChannel(args *DeleteChannelArgs, returns *DeleteChannelReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteChannel(channelId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteChannel(args.A)
	} else {
		return fmt.Errorf("API DeleteChannel called but not implemented.")
	}
	return nil
}

type GetChannelArgs struct {
	A string
}

type GetChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *APIRPCClient) GetChannel(channelId string) (*model.Channel, *model.AppError) {
	_args := &GetChannelArgs{channelId}
	_returns := &GetChannelReturns{}
	if err := g.client.Call("Plugin.GetChannel", _args, _returns); err != nil {
		g.log.Error("RPC call to GetChannel API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetChannel(args *GetChannelArgs, returns *GetChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannel(channelId string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannel(args.A)
	} else {
		return fmt.Errorf("API GetChannel called but not implemented.")
	}
	return nil
}

type GetChannelByNameArgs struct {
	A string
	B string
}

type GetChannelByNameReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *APIRPCClient) GetChannelByName(name, teamId string) (*model.Channel, *model.AppError) {
	_args := &GetChannelByNameArgs{name, teamId}
	_returns := &GetChannelByNameReturns{}
	if err := g.client.Call("Plugin.GetChannelByName", _args, _returns); err != nil {
		g.log.Error("RPC call to GetChannelByName API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetChannelByName(args *GetChannelByNameArgs, returns *GetChannelByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelByName(name, teamId string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelByName(args.A, args.B)
	} else {
		return fmt.Errorf("API GetChannelByName called but not implemented.")
	}
	return nil
}

type GetDirectChannelArgs struct {
	A string
	B string
}

type GetDirectChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *APIRPCClient) GetDirectChannel(userId1, userId2 string) (*model.Channel, *model.AppError) {
	_args := &GetDirectChannelArgs{userId1, userId2}
	_returns := &GetDirectChannelReturns{}
	if err := g.client.Call("Plugin.GetDirectChannel", _args, _returns); err != nil {
		g.log.Error("RPC call to GetDirectChannel API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetDirectChannel(args *GetDirectChannelArgs, returns *GetDirectChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetDirectChannel(userId1, userId2 string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetDirectChannel(args.A, args.B)
	} else {
		return fmt.Errorf("API GetDirectChannel called but not implemented.")
	}
	return nil
}

type GetGroupChannelArgs struct {
	A []string
}

type GetGroupChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *APIRPCClient) GetGroupChannel(userIds []string) (*model.Channel, *model.AppError) {
	_args := &GetGroupChannelArgs{userIds}
	_returns := &GetGroupChannelReturns{}
	if err := g.client.Call("Plugin.GetGroupChannel", _args, _returns); err != nil {
		g.log.Error("RPC call to GetGroupChannel API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetGroupChannel(args *GetGroupChannelArgs, returns *GetGroupChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetGroupChannel(userIds []string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetGroupChannel(args.A)
	} else {
		return fmt.Errorf("API GetGroupChannel called but not implemented.")
	}
	return nil
}

type UpdateChannelArgs struct {
	A *model.Channel
}

type UpdateChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *APIRPCClient) UpdateChannel(channel *model.Channel) (*model.Channel, *model.AppError) {
	_args := &UpdateChannelArgs{channel}
	_returns := &UpdateChannelReturns{}
	if err := g.client.Call("Plugin.UpdateChannel", _args, _returns); err != nil {
		g.log.Error("RPC call to UpdateChannel API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) UpdateChannel(args *UpdateChannelArgs, returns *UpdateChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannel(channel *model.Channel) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannel(args.A)
	} else {
		return fmt.Errorf("API UpdateChannel called but not implemented.")
	}
	return nil
}

type AddChannelMemberArgs struct {
	A string
	B string
}

type AddChannelMemberReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *APIRPCClient) AddChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError) {
	_args := &AddChannelMemberArgs{channelId, userId}
	_returns := &AddChannelMemberReturns{}
	if err := g.client.Call("Plugin.AddChannelMember", _args, _returns); err != nil {
		g.log.Error("RPC call to AddChannelMember API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) AddChannelMember(args *AddChannelMemberArgs, returns *AddChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		AddChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.AddChannelMember(args.A, args.B)
	} else {
		return fmt.Errorf("API AddChannelMember called but not implemented.")
	}
	return nil
}

type GetChannelMemberArgs struct {
	A string
	B string
}

type GetChannelMemberReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *APIRPCClient) GetChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError) {
	_args := &GetChannelMemberArgs{channelId, userId}
	_returns := &GetChannelMemberReturns{}
	if err := g.client.Call("Plugin.GetChannelMember", _args, _returns); err != nil {
		g.log.Error("RPC call to GetChannelMember API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetChannelMember(args *GetChannelMemberArgs, returns *GetChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelMember(args.A, args.B)
	} else {
		return fmt.Errorf("API GetChannelMember called but not implemented.")
	}
	return nil
}

type UpdateChannelMemberRolesArgs struct {
	A string
	B string
	C string
}

type UpdateChannelMemberRolesReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *APIRPCClient) UpdateChannelMemberRoles(channelId, userId, newRoles string) (*model.ChannelMember, *model.AppError) {
	_args := &UpdateChannelMemberRolesArgs{channelId, userId, newRoles}
	_returns := &UpdateChannelMemberRolesReturns{}
	if err := g.client.Call("Plugin.UpdateChannelMemberRoles", _args, _returns); err != nil {
		g.log.Error("RPC call to UpdateChannelMemberRoles API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) UpdateChannelMemberRoles(args *UpdateChannelMemberRolesArgs, returns *UpdateChannelMemberRolesReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannelMemberRoles(channelId, userId, newRoles string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannelMemberRoles(args.A, args.B, args.C)
	} else {
		return fmt.Errorf("API UpdateChannelMemberRoles called but not implemented.")
	}
	return nil
}

type UpdateChannelMemberNotificationsArgs struct {
	A string
	B string
	C map[string]string
}

type UpdateChannelMemberNotificationsReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *APIRPCClient) UpdateChannelMemberNotifications(channelId, userId string, notifications map[string]string) (*model.ChannelMember, *model.AppError) {
	_args := &UpdateChannelMemberNotificationsArgs{channelId, userId, notifications}
	_returns := &UpdateChannelMemberNotificationsReturns{}
	if err := g.client.Call("Plugin.UpdateChannelMemberNotifications", _args, _returns); err != nil {
		g.log.Error("RPC call to UpdateChannelMemberNotifications API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) UpdateChannelMemberNotifications(args *UpdateChannelMemberNotificationsArgs, returns *UpdateChannelMemberNotificationsReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannelMemberNotifications(channelId, userId string, notifications map[string]string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannelMemberNotifications(args.A, args.B, args.C)
	} else {
		return fmt.Errorf("API UpdateChannelMemberNotifications called but not implemented.")
	}
	return nil
}

type DeleteChannelMemberArgs struct {
	A string
	B string
}

type DeleteChannelMemberReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) DeleteChannelMember(channelId, userId string) *model.AppError {
	_args := &DeleteChannelMemberArgs{channelId, userId}
	_returns := &DeleteChannelMemberReturns{}
	if err := g.client.Call("Plugin.DeleteChannelMember", _args, _returns); err != nil {
		g.log.Error("RPC call to DeleteChannelMember API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) DeleteChannelMember(args *DeleteChannelMemberArgs, returns *DeleteChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteChannelMember(channelId, userId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteChannelMember(args.A, args.B)
	} else {
		return fmt.Errorf("API DeleteChannelMember called but not implemented.")
	}
	return nil
}

type CreatePostArgs struct {
	A *model.Post
}

type CreatePostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *APIRPCClient) CreatePost(post *model.Post) (*model.Post, *model.AppError) {
	_args := &CreatePostArgs{post}
	_returns := &CreatePostReturns{}
	if err := g.client.Call("Plugin.CreatePost", _args, _returns); err != nil {
		g.log.Error("RPC call to CreatePost API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) CreatePost(args *CreatePostArgs, returns *CreatePostReturns) error {
	if hook, ok := s.impl.(interface {
		CreatePost(post *model.Post) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreatePost(args.A)
	} else {
		return fmt.Errorf("API CreatePost called but not implemented.")
	}
	return nil
}

type DeletePostArgs struct {
	A string
}

type DeletePostReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) DeletePost(postId string) *model.AppError {
	_args := &DeletePostArgs{postId}
	_returns := &DeletePostReturns{}
	if err := g.client.Call("Plugin.DeletePost", _args, _returns); err != nil {
		g.log.Error("RPC call to DeletePost API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) DeletePost(args *DeletePostArgs, returns *DeletePostReturns) error {
	if hook, ok := s.impl.(interface {
		DeletePost(postId string) *model.AppError
	}); ok {
		returns.A = hook.DeletePost(args.A)
	} else {
		return fmt.Errorf("API DeletePost called but not implemented.")
	}
	return nil
}

type GetPostArgs struct {
	A string
}

type GetPostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *APIRPCClient) GetPost(postId string) (*model.Post, *model.AppError) {
	_args := &GetPostArgs{postId}
	_returns := &GetPostReturns{}
	if err := g.client.Call("Plugin.GetPost", _args, _returns); err != nil {
		g.log.Error("RPC call to GetPost API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) GetPost(args *GetPostArgs, returns *GetPostReturns) error {
	if hook, ok := s.impl.(interface {
		GetPost(postId string) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPost(args.A)
	} else {
		return fmt.Errorf("API GetPost called but not implemented.")
	}
	return nil
}

type UpdatePostArgs struct {
	A *model.Post
}

type UpdatePostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *APIRPCClient) UpdatePost(post *model.Post) (*model.Post, *model.AppError) {
	_args := &UpdatePostArgs{post}
	_returns := &UpdatePostReturns{}
	if err := g.client.Call("Plugin.UpdatePost", _args, _returns); err != nil {
		g.log.Error("RPC call to UpdatePost API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) UpdatePost(args *UpdatePostArgs, returns *UpdatePostReturns) error {
	if hook, ok := s.impl.(interface {
		UpdatePost(post *model.Post) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdatePost(args.A)
	} else {
		return fmt.Errorf("API UpdatePost called but not implemented.")
	}
	return nil
}

type KVSetArgs struct {
	A string
	B []byte
}

type KVSetReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) KVSet(key string, value []byte) *model.AppError {
	_args := &KVSetArgs{key, value}
	_returns := &KVSetReturns{}
	if err := g.client.Call("Plugin.KVSet", _args, _returns); err != nil {
		g.log.Error("RPC call to KVSet API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) KVSet(args *KVSetArgs, returns *KVSetReturns) error {
	if hook, ok := s.impl.(interface {
		KVSet(key string, value []byte) *model.AppError
	}); ok {
		returns.A = hook.KVSet(args.A, args.B)
	} else {
		return fmt.Errorf("API KVSet called but not implemented.")
	}
	return nil
}

type KVGetArgs struct {
	A string
}

type KVGetReturns struct {
	A []byte
	B *model.AppError
}

func (g *APIRPCClient) KVGet(key string) ([]byte, *model.AppError) {
	_args := &KVGetArgs{key}
	_returns := &KVGetReturns{}
	if err := g.client.Call("Plugin.KVGet", _args, _returns); err != nil {
		g.log.Error("RPC call to KVGet API failed.", mlog.Err(err))
	}
	return _returns.A, _returns.B
}

func (s *APIRPCServer) KVGet(args *KVGetArgs, returns *KVGetReturns) error {
	if hook, ok := s.impl.(interface {
		KVGet(key string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVGet(args.A)
	} else {
		return fmt.Errorf("API KVGet called but not implemented.")
	}
	return nil
}

type KVDeleteArgs struct {
	A string
}

type KVDeleteReturns struct {
	A *model.AppError
}

func (g *APIRPCClient) KVDelete(key string) *model.AppError {
	_args := &KVDeleteArgs{key}
	_returns := &KVDeleteReturns{}
	if err := g.client.Call("Plugin.KVDelete", _args, _returns); err != nil {
		g.log.Error("RPC call to KVDelete API failed.", mlog.Err(err))
	}
	return _returns.A
}

func (s *APIRPCServer) KVDelete(args *KVDeleteArgs, returns *KVDeleteReturns) error {
	if hook, ok := s.impl.(interface {
		KVDelete(key string) *model.AppError
	}); ok {
		returns.A = hook.KVDelete(args.A)
	} else {
		return fmt.Errorf("API KVDelete called but not implemented.")
	}
	return nil
}

type PublishWebSocketEventArgs struct {
	A string
	B map[string]interface{}
	C *model.WebsocketBroadcast
}

type PublishWebSocketEventReturns struct {
}

func (g *APIRPCClient) PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast) {
	_args := &PublishWebSocketEventArgs{event, payload, broadcast}
	_returns := &PublishWebSocketEventReturns{}
	if err := g.client.Call("Plugin.PublishWebSocketEvent", _args, _returns); err != nil {
		g.log.Error("RPC call to PublishWebSocketEvent API failed.", mlog.Err(err))
	}
	return
}

func (s *APIRPCServer) PublishWebSocketEvent(args *PublishWebSocketEventArgs, returns *PublishWebSocketEventReturns) error {
	if hook, ok := s.impl.(interface {
		PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast)
	}); ok {
		hook.PublishWebSocketEvent(args.A, args.B, args.C)
	} else {
		return fmt.Errorf("API PublishWebSocketEvent called but not implemented.")
	}
	return nil
}

type LogDebugArgs struct {
	A string
	B []interface{}
}

type LogDebugReturns struct {
}

func (g *APIRPCClient) LogDebug(msg string, keyValuePairs ...interface{}) {
	_args := &LogDebugArgs{msg, keyValuePairs}
	_returns := &LogDebugReturns{}
	if err := g.client.Call("Plugin.LogDebug", _args, _returns); err != nil {
		g.log.Error("RPC call to LogDebug API failed.", mlog.Err(err))
	}
	return
}

func (s *APIRPCServer) LogDebug(args *LogDebugArgs, returns *LogDebugReturns) error {
	if hook, ok := s.impl.(interface {
		LogDebug(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogDebug(args.A, args.B...)
	} else {
		return fmt.Errorf("API LogDebug called but not implemented.")
	}
	return nil
}

type LogInfoArgs struct {
	A string
	B []interface{}
}

type LogInfoReturns struct {
}

func (g *APIRPCClient) LogInfo(msg string, keyValuePairs ...interface{}) {
	_args := &LogInfoArgs{msg, keyValuePairs}
	_returns := &LogInfoReturns{}
	if err := g.client.Call("Plugin.LogInfo", _args, _returns); err != nil {
		g.log.Error("RPC call to LogInfo API failed.", mlog.Err(err))
	}
	return
}

func (s *APIRPCServer) LogInfo(args *LogInfoArgs, returns *LogInfoReturns) error {
	if hook, ok := s.impl.(interface {
		LogInfo(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogInfo(args.A, args.B...)
	} else {
		return fmt.Errorf("API LogInfo called but not implemented.")
	}
	return nil
}

type LogErrorArgs struct {
	A string
	B []interface{}
}

type LogErrorReturns struct {
}

func (g *APIRPCClient) LogError(msg string, keyValuePairs ...interface{}) {
	_args := &LogErrorArgs{msg, keyValuePairs}
	_returns := &LogErrorReturns{}
	if err := g.client.Call("Plugin.LogError", _args, _returns); err != nil {
		g.log.Error("RPC call to LogError API failed.", mlog.Err(err))
	}
	return
}

func (s *APIRPCServer) LogError(args *LogErrorArgs, returns *LogErrorReturns) error {
	if hook, ok := s.impl.(interface {
		LogError(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogError(args.A, args.B...)
	} else {
		return fmt.Errorf("API LogError called but not implemented.")
	}
	return nil
}

type LogWarnArgs struct {
	A string
	B []interface{}
}

type LogWarnReturns struct {
}

func (g *APIRPCClient) LogWarn(msg string, keyValuePairs ...interface{}) {
	_args := &LogWarnArgs{msg, keyValuePairs}
	_returns := &LogWarnReturns{}
	if err := g.client.Call("Plugin.LogWarn", _args, _returns); err != nil {
		g.log.Error("RPC call to LogWarn API failed.", mlog.Err(err))
	}
	return
}

func (s *APIRPCServer) LogWarn(args *LogWarnArgs, returns *LogWarnReturns) error {
	if hook, ok := s.impl.(interface {
		LogWarn(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogWarn(args.A, args.B...)
	} else {
		return fmt.Errorf("API LogWarn called but not implemented.")
	}
	return nil
}
